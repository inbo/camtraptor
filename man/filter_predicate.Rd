% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_predicates.R
\name{pred}
\alias{pred}
\alias{pred_not}
\alias{pred_gt}
\alias{pred_gte}
\alias{pred_lt}
\alias{pred_lte}
\alias{pred_in}
\alias{pred_notin}
\alias{pred_na}
\alias{pred_notna}
\alias{pred_and}
\alias{pred_or}
\title{Filter predicate}
\usage{
pred(arg, value)

pred_not(arg, value)

pred_gt(arg, value)

pred_gte(arg, value)

pred_lt(arg, value)

pred_lte(arg, value)

pred_in(arg, value)

pred_notin(arg, value)

pred_na(arg)

pred_notna(arg)

pred_and(...)

pred_or(...)
}
\arguments{
\item{arg}{(character) The key for the predicate.
See "Keys" below.}

\item{value}{(various) The value for the predicate.}

\item{...}{For \code{pred_or()} or \code{pred_and()}: one or more objects of
class \code{filter_predicate}, created by any other \verb{pred*} function.}
}
\value{
A predicate object.
An object of class predicate is a list with the following elements:
\itemize{
\item \code{arg}: A (list of) character with all arguments in the predicate(s).
\item \code{value}: A (list of) character with all values in the predicate(s).
\item \code{type}: A (list of) character with all predicate types, see section
"predicate methods" here below.
\item \code{expr}: A character: body of a filter expression.
}
}
\description{
Filter predicate
}
\section{Predicate methods and their equivalent types}{

\verb{pred*} functions are named for the 'type' of operation they do, inspired by
GBIF \href{https://www.gbif.org/developer/occurrence#predicates}{occurrence predicates}

The following functions take one key and one value and are associated to the
following types:
\itemize{
\item \code{pred}: equals
\item \code{pred_not}: notEquals
\item \code{pred_lt}: lessThan
\item \code{pred_lte}: lessThanOrEquals
\item \code{pred_gt}: greaterThan
\item \code{pred_gte}: greaterThanOrEquals
\item \code{pred_like}: like (NOT IMPLEMENTED YET!)
}

The following function is only for geospatial queries, and only accepts a
WKT string:
\itemize{
\item \code{pred_within}: within (NOT IMPLEMENTED YET!)
}

The following functions are only for stating that you do (not) want a key to
be \code{NA}, so only accepts one key:
\itemize{
\item \code{pred_na}: isNA
\item \code{pred_notna}: isNotNA
}

The following two functions accept multiple individual filter predicates,
separating them by either "and" or "or":
\itemize{
\item \code{pred_and}: and
\item \code{pred_or}: or
}

The following function is special in that it accepts a single key but many
values, stating that you want to search for all the listed values, e.g.
one of the locations in: "B_ML_val 05_molenkreek", "B_ML_val 03_De Val" and
"B_ML_val 06_Oostpolderkreek"
\itemize{
\item \code{pred_in}: in
\item \code{pred_notin}: notIn
}
}

\section{What happens internally}{

Internally, the input to \verb{pred*} functions turn into a character string,
which forms the body of a filter expression.
For example:

\code{pred("tags", "boven de stroom")} gives:

\if{html}{\out{<div class="sourceCode">}}\preformatted{$arg
[1] "tags"

$value
[1] "boven de stroom"

$type
[1] "equals"

$expr
(tags == "boven de stroom")
}\if{html}{\out{</div>}}

\code{pred_gt("latitude", 51.27)} gives, (only \code{expr} element shown):

\if{html}{\out{<div class="sourceCode">}}\preformatted{(latitude > 51.27)
}\if{html}{\out{</div>}}

\code{pred_or()} gives:

\if{html}{\out{<div class="sourceCode">}}\preformatted{((tags == "boven de stroom") | (latitude > 51.28))
}\if{html}{\out{</div>}}

\code{pred_or()} gives:

\if{html}{\out{<div class="sourceCode">}}\preformatted{((tags == "boven de stroom") & (latitude > 51.28))
}\if{html}{\out{</div>}}
}

\section{Keys}{

Acceptable arguments to the \code{key} parameter are the column names of the
data frame you are applying the filter predicates.
}

\examples{
# One arg one value predicates
pred("scientificName", "Anas platyrhynchos")
pred("tags", "boven de stroom")
pred_gt("latitude", 51.18)
pred_gte("latitude", 51.18)
pred_lt("longitude", 3.95)
pred_lte("longitude", 3.95)
pred_not("locationName", "B_DL_val 3_dikke boom")

# and/or predicates
pred_and(pred_lt("longitude", 3.59), pred_gt("latitude", 51.28))
pred_or(pred_gte("count", 2), pred("vernacular_name", "Norway Rat"))

# Use dates as argument
start_date <- as.Date("2020-06-03", format = "\%Y-\%m-\%d")
end_date <- as.Date("2020-06-10", format = "\%Y-\%m-\%d")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# Use datetimes (POSIXct) as argument
start_date <- lubridate::as_datetime("2020-06-03")
end_date <- lubridate::as_datetime("2020-06-10")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# One arg multiple values predicates
locations <- c("B_ML_val 03_De Val", "B_ML_val 05_molenkreek")
pred_in("location_name", locations)
pred_notin("location_name", locations)
start_dates <- lubridate::as_datetime(c("2020-06-03 20:10:18", "2020-06-03 20:04:33"))
pred_in("start", start_dates)
pred_notin("start", start_dates)

# One arg, no value predicates
pred_na("scientificName")
pred_notna("scientificName")
}
\seealso{
Other filter functions: 
\code{\link{apply_filter_predicate}()}
}
\concept{filter functions}
